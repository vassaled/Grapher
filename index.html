<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Grapher</title>
<style>
:root { --bg:#121212; --panel:#1e1e1e; --border:#333; --text:#e0e0e0; --accent:#007bff; }
body { margin:0; background:var(--bg); color:var(--text); font-family:'Segoe UI', monospace; display:flex; height:100vh; overflow:hidden; }
#sidebar { width:360px; flex-shrink:0; background:var(--panel); border-right:1px solid var(--border); display:flex; flex-direction:column; transition:margin-left 0.3s ease; z-index:2; }
#sidebar.collapsed { margin-left:-360px; }
#expression-list { flex-grow:1; overflow-y:auto; padding:10px; }
.expr-row { display:flex; align-items:center; background:#2a2a2a; margin-bottom:8px; padding:6px; border-radius:4px; border-left:4px solid #666; }
.expr-color { width:12px; height:12px; border-radius:50%; margin-right:10px; flex-shrink:0; }
.expr-input { flex-grow:1; background:transparent; border:none; color:#fff; font-size:15px; outline:none; min-width:0; }
.expr-delete { color:#888; cursor:pointer; padding:0 8px; font-weight:bold; }
.expr-delete:hover { color:#ff4444; }
#toolbar { padding:15px; border-top:1px solid var(--border); display:flex; gap:10px; }
button { background:#333; color:white; border:1px solid #555; padding:8px 14px; cursor:pointer; border-radius:4px; }
button:hover { background:#444; }
button.primary { background:var(--accent); border-color:var(--accent); width:100%; }
#canvas-wrapper { flex-grow:1; position:relative; cursor:crosshair; min-width:0; }
canvas { display:block; width:100%; height:100%; }
#sliders { padding:12px; border-top:1px solid #333; }
#sliders label { font-size:12px; display:block; margin-top:8px; }
#sliders input { width:100%; }
.note { font-size:11px; color:#888; margin-top:6px; line-height:1.4; }

#toggle-btn {
    position:absolute;
    left:0;
    top:50%;
    transform:translateY(-50%);
    background:var(--panel);
    border:1px solid var(--border);
    border-left:none;
    color:var(--text);
    padding:16px 8px;
    cursor:pointer;
    border-radius:0 6px 6px 0;
    z-index:10;
    user-select:none;
    display:flex;
    align-items:center;
    justify-content:center;
    box-shadow:2px 0 5px rgba(0,0,0,0.2);
}
#toggle-btn:hover { background:#2a2a2a; }
</style>
</head>
<body>

<div id="sidebar">
    <div style="padding:15px; border-bottom:1px solid #333;">
        <h2 style="margin:0;">Grapher</h2>
        <div style="font-size:12px;color:#888;">Version 0.1</div>
    </div>
    <div id="expression-list"></div>
    <div id="toolbar">
        <button class="primary" onclick="addExpression()">+ Add Equation</button>
    </div>
</div>

<div id="canvas-wrapper">
    <div id="toggle-btn" onclick="toggleSidebar()">◀</div>
    <canvas id="graph"></canvas>
</div>

<script>
const COLORS = ['#ff4d4d','#4dff4d','#4d4dff','#ffff4d','#ff4dff','#4dffff'];
let expressions = [
    { text:"", color:COLORS[0], meta:null }
];
let vars = {}; 

const canvas = document.getElementById('graph');
const ctx = canvas.getContext('2d', {alpha:false});
let width, height;
let view = { x:0, y:0, scale:40 };
let drag = { active:false, lastX:0, lastY:0 };
let mousePos = { x:null, y:null };
let renderId;

function toggleSidebar() {
    const sidebar = document.getElementById('sidebar');
    const btn = document.getElementById('toggle-btn');
    sidebar.classList.toggle('collapsed');
    btn.innerText = sidebar.classList.contains('collapsed') ? '▶' : '◀';
}

function prepareExpression(expr){
    if(!expr) return expr;
    expr = expr
        .replace(/(\d)\s*([a-zA-Z_(])/g,'$1*$2')
        .replace(/([a-zA-Z_])\s*(\d)/g,'$1*$2')
        .replace(/(\))\s*(\()/g,'$1*$2')
        .replace(/(\d)\s*\(/g,'$1*(')
        .replace(/\)\s*([a-zA-Z_])/g,')*$1');
    expr = expr.replace(/\^/g,'**');
    expr = expr.replace(/\bpi\b/gi,'Math.PI');
    expr = expr.replace(/\be\b/gi,'Math.E');
    expr = expr.replace(/\b(sin|cos|tan|asin|acos|atan|sqrt|abs|log|exp|floor|ceil|pow)\b/gi, m => 'Math.'+m.toLowerCase());
    return expr;
}

function findIdentifiers(str){
    let tokens = new Set();
    let matches = (str.match(/[a-zA-Z_][a-zA-Z0-9_]*/g) || []);
    for(let t of matches){
        if(/^Math$/.test(t)) continue;
        if(/^(sin|cos|tan|asin|acos|atan|sqrt|abs|log|exp|floor|ceil|pow|pi|e)$/i.test(t)) continue;
        tokens.add(t);
    }
    return Array.from(tokens);
}

function parseMath(str){
    try{
        if(!str || !str.trim()) return null;
        let raw = str.trim();
        let clean = raw.replace(/\s+/g,'');
        let lower = clean.toLowerCase();

        let assignMatch = clean.match(/^([a-zA-Z_][a-zA-Z0-9_]*)=(.+)$/);
        if (assignMatch && !/^[xy]$/i.test(assignMatch[1])) {
            let varName = assignMatch[1].toLowerCase();
            let rhs = prepareExpression(assignMatch[2]);
            let rhsIds = findIdentifiers(rhs);
            if (!rhsIds.includes('x') && !rhsIds.includes('y') && !rhsIds.includes('t')) {
                return {
                    type: 'assignment',
                    raw: raw,
                    varName: varName,
                    ids: rhsIds,
                    fn: new Function('vars', `with(vars||{}){ return ${rhs}; }`)
                };
            }
        }

        if(/x\s*=/.test(lower) && /y\s*=/.test(lower)){
            let parts = clean.split(',');
            let xPart = parts.find(p=>/x\s*=/.test(p.toLowerCase()));
            let yPart = parts.find(p=>/y\s*=/.test(p.toLowerCase()));
            let xExpr = prepareExpression(xPart.split('=')[1]);
            let yExpr = prepareExpression(yPart.split('=')[1]);
            return {
                type:'parametric', raw:raw, ids:findIdentifiers(xExpr + yExpr),
                fn:new Function('t','vars', `with(vars||{}){ return {x:(${xExpr}), y:(${yExpr})}; }`)
            };
        }

        let parts = clean.split('=');
        let lhs = parts.length > 1 ? prepareExpression(parts[0]) : 'y';
        let rhs = parts.length > 1 ? prepareExpression(parts.slice(1).join('=')) : prepareExpression(clean);
        let expr = `(${lhs}) - (${rhs})`;
        return {
            type:'implicit', raw:raw, ids:findIdentifiers(expr),
            fn:new Function('x','y','vars', `with(vars||{}){ return ${expr}; }`)
        };
    }catch(e){ return null; }
}

function draw(){
    ctx.fillStyle="#121212";
    ctx.fillRect(0,0,width,height);
    drawGrid();
    const RESOLUTION = Math.max(2, Math.floor(8/(view.scale/40)));

    expressions.forEach(eq=>{
        if(!eq.meta || !eq.meta.fn || eq.meta.type === 'assignment') return;
        ctx.strokeStyle=eq.color;
        ctx.fillStyle=eq.color;
        ctx.lineWidth = 1.2;

        if(eq.meta.type==='parametric'){
            ctx.beginPath();
            let first=true;
            for(let t=-10; t<=10; t+=0.01){
                try{
                    let p = eq.meta.fn(t,vars);
                    let px = p.x*view.scale + width/2 + view.x;
                    let py = height/2 + view.y - p.y*view.scale;
                    if(first){ ctx.moveTo(px,py); first=false; } else ctx.lineTo(px,py);
                }catch(e){}
            }
            ctx.stroke();
            return;
        }

        const ids = (eq.meta.ids || []).map(id => id.toLowerCase());
        const primaryVar = ids.find(id => id !== 'y' && vars[id] === undefined) || 'x';

        for(let screenX=0; screenX<width; screenX+=RESOLUTION){
            let mx = (screenX - width/2 - view.x)/view.scale;
            for(let screenY=0; screenY<height; screenY+=RESOLUTION){
                let my = -((screenY - height/2 - view.y)/view.scale);
                let localVars = {...vars};
                localVars[primaryVar] = mx;

                try{
                    let val = eq.meta.fn(mx,my,localVars);
                    
                    let localVarsR = {...localVars};
                    localVarsR[primaryVar] = mx + RESOLUTION/view.scale;
                    let valR = eq.meta.fn(mx + RESOLUTION/view.scale, my, localVarsR);
                    
                    let valD = eq.meta.fn(mx, my - RESOLUTION/view.scale, localVars);
                    
                    if(Math.sign(val)!==Math.sign(valR)){
                        ctx.fillRect(screenX + (val/(val-valR))*RESOLUTION, screenY, 1.5, 1.5);
                    }
                    if(Math.sign(val)!==Math.sign(valD)){
                        ctx.fillRect(screenX, screenY + (val/(val-valD))*RESOLUTION, 1.5, 1.5);
                    }
                }catch(e){}
            }
        }
    });

    if (mousePos.x !== null) drawTooltip();
}

function drawTooltip() {
    if (drag.active) return;
    const radius = 16;
    let pointSets = [];
    
    expressions.forEach(eq => {
        if(!eq.meta || !eq.meta.fn || eq.meta.type==='parametric' || eq.meta.type === 'assignment') return;
        let pts = [];
        const ids = (eq.meta.ids || []).map(id => id.toLowerCase());
        const primaryVar = ids.find(id => id !== 'y' && vars[id] === undefined) || 'x';
        
        let localVars = {...vars};
        try {
            for(let sx = mousePos.x - radius; sx <= mousePos.x + radius; sx += 2) {
                let lx = (sx - width/2 - view.x)/view.scale;
                localVars[primaryVar] = lx;
                for(let sy = mousePos.y - radius; sy <= mousePos.y + radius; sy += 2) {
                    let ly = -((sy - height/2 - view.y)/view.scale);
                    
                    let val = eq.meta.fn(lx, ly, localVars);
                    let valR = eq.meta.fn(lx + 2/view.scale, ly, localVars);
                    let valD = eq.meta.fn(lx, ly - 2/view.scale, localVars);
                    
                    if(Math.sign(val) !== Math.sign(valR) || Math.sign(val) !== Math.sign(valD)){
                        pts.push({x: sx, y: sy, mx: lx, my: ly});
                    }
                }
            }
        } catch(e) {}
        if(pts.length > 0) pointSets.push(pts);
    });

    let xPts = [], yPts = [];
    for(let sx = mousePos.x - radius; sx <= mousePos.x + radius; sx += 2) {
        let lx = (sx - width/2 - view.x)/view.scale;
        for(let sy = mousePos.y - radius; sy <= mousePos.y + radius; sy += 2) {
            let ly = -((sy - height/2 - view.y)/view.scale);
            if(Math.abs(ly) <= 2/view.scale) xPts.push({x:sx, y:sy, mx:lx, my:0});
            if(Math.abs(lx) <= 2/view.scale) yPts.push({x:sx, y:sy, mx:0, my:ly});
        }
    }
    if(xPts.length > 0) pointSets.push(xPts);
    if(yPts.length > 0) pointSets.push(yPts);

    let bestDist = Infinity;
    let target = null;

    for(let i=0; i<pointSets.length; i++){
        for(let j=i+1; j<pointSets.length; j++){
            for(let p1 of pointSets[i]){
                for(let p2 of pointSets[j]){
                    let d = Math.hypot(p1.x - p2.x, p1.y - p2.y);
                    if(d < 6 && d < bestDist){
                        bestDist = d;
                        target = { x: (p1.x+p2.x)/2, y: (p1.y+p2.y)/2, mx: (p1.mx+p2.mx)/2, my: (p1.my+p2.my)/2 };
                    }
                }
            }
        }
    }

    if (target) {
        if (Math.abs(target.mx) < 0.05) target.mx = 0;
        if (Math.abs(target.my) < 0.05) target.my = 0;

        ctx.beginPath();
        ctx.arc(target.x, target.y, 5, 0, Math.PI*2);
        ctx.fillStyle = '#1e1e1e';
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#fff';
        ctx.stroke();

        let txt = `(${Math.round(target.mx*100)/100}, ${Math.round(target.my*100)/100})`;
        ctx.font = '12px "Segoe UI", monospace';
        let tw = ctx.measureText(txt).width;
        ctx.fillStyle = 'rgba(0,0,0,0.8)';
        ctx.fillRect(target.x + 10, target.y - 12, tw + 16, 24);
        ctx.fillStyle = '#fff';
        ctx.fillText(txt, target.x + 18, target.y + 4);
        canvas.style.cursor = 'pointer';
    } else {
        canvas.style.cursor = 'crosshair';
    }
}

function drawGrid(){
    ctx.strokeStyle="#333"; ctx.lineWidth=1; ctx.beginPath();
    let startX=Math.floor((-width/2-view.x)/view.scale) - 1;
    let endX=Math.ceil((width/2-view.x)/view.scale) + 1;
    for(let i=startX;i<=endX;i++){
        let px=i*view.scale+width/2+view.x;
        ctx.moveTo(px,0); ctx.lineTo(px,height);
    }
    let startY=Math.floor((-height/2+view.y)/view.scale) - 1;
    let endY=Math.ceil((height/2+view.y)/view.scale) + 1;
    for(let i=startY;i<=endY;i++){
        let py=height/2+view.y-i*view.scale;
        ctx.moveTo(0,py); ctx.lineTo(width,py);
    }
    ctx.stroke();
    ctx.strokeStyle="#888"; ctx.lineWidth=2; ctx.beginPath();
    ctx.moveTo(width/2+view.x, 0); ctx.lineTo(width/2+view.x, height);
    ctx.moveTo(0, height/2+view.y); ctx.lineTo(width, height/2+view.y);
    ctx.stroke();
}

const listEl=document.getElementById('expression-list');
function renderList(){
    listEl.innerHTML='';
    expressions.forEach((expr,i)=>{
        let row=document.createElement('div');
        row.className='expr-row';
        row.style.borderLeftColor=expr.color;
        row.innerHTML=`
            <div class="expr-color" style="background:${expr.color}"></div>
            <input class="expr-input" value="${expr.text}" oninput="updateExpr(${i},this.value)" placeholder="Enter equation...">
            <span class="expr-delete" onclick="removeExpr(${i})">×</span>
        `;
        listEl.appendChild(row);
        expressions[i].meta = parseMath(expr.text);
    });
    inferVarsAndSliders();
    requestDraw();
}

function inferVarsAndSliders(){
    let collected = new Set();
    let explicitX = false;
    let explicitAssignments = {};
    let assignmentSources = {};

    expressions.forEach((expr, i) => {
        if(expr.meta && expr.meta.type === 'assignment') {
            try {
                let evalContext = {...vars, ...explicitAssignments};
                let val = expr.meta.fn(evalContext);
                if(typeof val === 'number' && !isNaN(val)) {
                    explicitAssignments[expr.meta.varName] = val;
                    assignmentSources[expr.meta.varName] = i;
                    collected.add(expr.meta.varName);
                }
            } catch(e) {}
        }
    });

    expressions.forEach(expr => {
        if (!expr.meta || expr.meta.type === 'assignment') return;
        let ids = (expr.meta.ids || []).map(id => id.toLowerCase()).filter(id => id !== 'y');
        if (ids.includes('x')) explicitX = true;
        ids.forEach(id => collected.add(id));
    });

    let globalIndependentVars = new Set(['t']);

    if (explicitX) {
        globalIndependentVars.add('x');
    } else {
        expressions.forEach(expr => {
            if (!expr.meta || expr.meta.type === 'assignment') return;
            let ids = (expr.meta.ids || []).map(id => id.toLowerCase()).filter(id => id !== 'y');
            let freeVars = ids.filter(id => explicitAssignments[id] === undefined);
            if (freeVars.length === 1) {
                globalIndependentVars.add(freeVars[0]);
            }
        });
    }

    let newVars = {};
    collected.forEach(id => {
        if (globalIndependentVars.has(id)) return;
        if (explicitAssignments[id] !== undefined) {
            newVars[id] = explicitAssignments[id];
        } else {
            newVars[id] = (vars[id] !== undefined) ? vars[id] : 1;
        }
    });

    vars = newVars;
    renderSliders(assignmentSources);
}

function renderSliders(assignmentSources){
    let existing=document.getElementById('sliders');
    if(existing) existing.remove();
    
    let sliderVars = Object.keys(vars);
    if(sliderVars.length === 0) return;
    
    let box=document.createElement('div');
    box.id='sliders';
    box.innerHTML = '<div class="note">Variables not acting as the X-axis appear as sliders.</div>';
    sliderVars.forEach(v=>{
        let label=document.createElement('label');
        label.innerText=`${v}: ${vars[v]}`;
        
        let input=document.createElement('input');
        input.type='range'; 
        
        let currentVal = vars[v];
        input.min = Math.min(-10, Math.floor(currentVal * 1.5));
        input.max = Math.max(10, Math.ceil(currentVal * 1.5));
        input.step=0.1; 
        input.value=currentVal;
        
        input.oninput=()=>{
            let newVal = parseFloat(input.value);
            vars[v] = newVal;
            label.innerText = `${v}: ${newVal}`;
            
            if (assignmentSources && assignmentSources[v] !== undefined) {
                let idx = assignmentSources[v];
                expressions[idx].text = `${v}=${newVal}`;
                expressions[idx].meta = parseMath(expressions[idx].text);
                
                let inputFields = document.querySelectorAll('.expr-input');
                if (inputFields[idx]) {
                    inputFields[idx].value = expressions[idx].text;
                }
            }
            
            requestDraw();
        };
        box.appendChild(label);
        box.appendChild(input);
    });
    document.getElementById('sidebar').appendChild(box);
}

window.updateExpr=(i,text)=>{
    expressions[i].text=text;
    expressions[i].meta = parseMath(text);
    inferVarsAndSliders();
    requestDraw();
};

window.addExpression=()=>{
    expressions.push({text:"",color:COLORS[expressions.length%COLORS.length],meta:null});
    renderList();
};

window.removeExpr=i=>{
    expressions.splice(i,1);
    if(expressions.length === 0) {
        expressions.push({text:"",color:COLORS[0],meta:null});
    }
    renderList();
    requestDraw();
};

function requestDraw(){
    if(renderId) cancelAnimationFrame(renderId);
    renderId=requestAnimationFrame(draw);
}

function resize(){
    width=canvas.parentElement.clientWidth;
    height=canvas.parentElement.clientHeight;
    canvas.width=width;
    canvas.height=height;
    requestDraw();
}

new ResizeObserver(resize).observe(document.getElementById('canvas-wrapper'));

canvas.addEventListener('mousedown',e=>{
    drag.active=true;
    drag.lastX=e.clientX;
    drag.lastY=e.clientY;
});
canvas.addEventListener('mouseup',()=>drag.active=false);
canvas.addEventListener('mousemove',e=>{
    if(drag.active){
        view.x+=e.clientX-drag.lastX; 
        view.y+=e.clientY-drag.lastY;
        drag.lastX=e.clientX; 
        drag.lastY=e.clientY;
        mousePos.x = null;
    } else {
        const rect = canvas.getBoundingClientRect();
        mousePos.x = e.clientX - rect.left;
        mousePos.y = e.clientY - rect.top;
    }
    requestDraw();
});
canvas.addEventListener('mouseleave', () => {
    mousePos.x = null;
    mousePos.y = null;
    drag.active = false;
    requestDraw();
});
canvas.addEventListener('wheel',e=>{
    e.preventDefault();
    const oldScale = view.scale;
    view.scale *= e.deltaY>0?0.9:1.1;
    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left - width/2 - view.x)/oldScale;
    const my = -((e.clientY - rect.top - height/2 - view.y)/oldScale);
    view.x = view.x - (view.scale - oldScale)*mx;
    view.y = view.y + (view.scale - oldScale)*my;
    requestDraw();
});

renderList();
</script>
</body>
</html>