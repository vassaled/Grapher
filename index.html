<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Grapher</title>
<style>
:root { --bg:#121212; --panel:#1e1e1e; --border:#333; --text:#e0e0e0; --accent:#007bff; }
body { margin:0; background:var(--bg); color:var(--text); font-family:'Segoe UI', monospace; display:flex; height:100vh; overflow:hidden; }
#sidebar { width:360px; flex-shrink:0; background:var(--panel); border-right:1px solid var(--border); display:flex; flex-direction:column; transition:margin-left 0.3s ease; z-index:2; }
#sidebar.collapsed { margin-left:-360px; }
#expression-list { flex-grow:1; overflow-y:auto; padding:10px; }
.expr-row-container { margin-bottom:8px; }
.expr-row { display:flex; align-items:center; background:#2a2a2a; padding:6px; border-radius:4px; border-left:4px solid #666; }
.expr-color { width:12px; height:12px; border-radius:50%; margin-right:10px; flex-shrink:0; }
.expr-input { flex-grow:1; background:transparent; border:none; color:#fff; font-size:15px; outline:none; min-width:0; }
.expr-delete { color:#888; cursor:pointer; padding:0 8px; font-weight:bold; }
.expr-delete:hover { color:#ff4444; }
.expr-result { padding:2px 0 2px 32px; color:#aaa; font-size:13px; font-weight:bold; }
.slider-prompt { display:flex; align-items:center; padding:6px 0 0 32px; gap:6px; }
.prompt-btn { background:transparent; color:var(--accent); border:1px solid #333; padding:2px 8px; border-radius:12px; font-size:11px; cursor:pointer; }
.prompt-btn:hover { background:var(--accent); color:#fff; border-color:var(--accent); }
#toolbar { padding:15px; border-top:1px solid var(--border); display:flex; gap:10px; }
button { background:#333; color:white; border:1px solid #555; padding:8px 14px; cursor:pointer; border-radius:4px; }
button:hover { background:#444; }
button.primary { background:var(--accent); border-color:var(--accent); width:100%; }
#canvas-wrapper { flex-grow:1; position:relative; cursor:crosshair; min-width:0; }
canvas { display:block; width:100%; height:100%; }
#sliders { padding:12px; border-top:1px solid #333; }
#sliders label { font-size:12px; display:block; margin-top:8px; }
#sliders input[type="range"] { width:100%; margin-top: 6px; }
.note { font-size:11px; color:#888; margin-top:6px; line-height:1.4; }

.slider-header { display:flex; justify-content:space-between; align-items:center; margin-top:10px; }
.play-btn { background:transparent; border:1px solid var(--accent); color:var(--accent); border-radius:4px; padding:2px 8px; font-size:11px; cursor:pointer; }
.play-btn:hover { background:var(--accent); color:#fff; }

#toggle-btn {
    position:absolute; left:0; top:50%; transform:translateY(-50%);
    background:var(--panel); border:1px solid var(--border); border-left:none;
    color:var(--text); padding:16px 8px; cursor:pointer; border-radius:0 6px 6px 0;
    z-index:10; user-select:none; display:flex; align-items:center; justify-content:center;
    box-shadow:2px 0 5px rgba(0,0,0,0.2);
}
#toggle-btn:hover { background:#2a2a2a; }
</style>
</head>
<body>

<div id="sidebar">
    <div style="padding:15px; border-bottom:1px solid #333;">
        <h2 style="margin:0;">Grapher</h2>
        <div style="font-size:12px;color:#888;">Version 0.2(b(0.2))</div>
    </div>
    <div id="expression-list"></div>
    <div id="toolbar">
        <button class="primary" onclick="addExpression()">+ Add Equation</button>
    </div>
</div>

<div id="canvas-wrapper">
    <div id="toggle-btn" onclick="toggleSidebar()">◀</div>
    <canvas id="graph"></canvas>
</div>

<script>
const COLORS = ['#ff4d4d','#4dff4d','#4d4dff','#ffff4d','#ff4dff','#4dffff'];
let expressions = [
    { text:"", color:COLORS[0], meta:null }
];
let vars = {}; 
let animState = {};

const canvas = document.getElementById('graph');
const ctx = canvas.getContext('2d', {alpha:false});
let width, height;
let view = { x:0, y:0, scale:40 };
let drag = { active:false, lastX:0, lastY:0 };
let mousePos = { x:null, y:null };
let renderId;

let explicitParams = new Set();
let explicitAssignments = {};
let assignmentSources = {};
let pendingPrompts = {};
const listEl = document.getElementById('expression-list');

function toggleSidebar() {
    const sidebar = document.getElementById('sidebar');
    const btn = document.getElementById('toggle-btn');
    sidebar.classList.toggle('collapsed');
    btn.innerText = sidebar.classList.contains('collapsed') ? '▶' : '◀';
}

function prepareExpression(expr){
    if(!expr) return expr;
    expr = expr
        .replace(/(\d)\s*([a-zA-Z_(])/g,'$1*$2')
        .replace(/([a-zA-Z_])\s*(\d)/g,'$1*$2')
        .replace(/(\))\s*(\()/g,'$1*$2')
        .replace(/(\d)\s*\(/g,'$1*(')
        .replace(/\)\s*([a-zA-Z_])/g,')*$1');
    expr = expr.replace(/\^/g,'**');
    expr = expr.replace(/\bpi\b/gi,'Math.PI');
    expr = expr.replace(/\be\b/gi,'Math.E');
    expr = expr.replace(/\b(sin|cos|tan|asin|acos|atan|sqrt|abs|log|exp|floor|ceil|pow)\b/gi, m => 'Math.'+m.toLowerCase());
    return expr;
}

function findIdentifiers(str){
    let tokens = new Set();
    let matches = (str.match(/[a-zA-Z_][a-zA-Z0-9_]*/g) || []);
    for(let t of matches){
        if(/^Math$/.test(t)) continue;
        if(/^(sin|cos|tan|asin|acos|atan|sqrt|abs|log|exp|floor|ceil|pow|pi|e)$/i.test(t)) continue;
        tokens.add(t);
    }
    return Array.from(tokens);
}

function buildDestructure(ids) {
    let structIds = ids.filter(id => !['x','y','t'].includes(id));
    return structIds.length > 0 ? `const {${structIds.join(',')}} = vars || {}; ` : '';
}

function parseMath(str){
    try{
        if(!str || !str.trim()) return null;
        let raw = str.trim();
        let clean = raw.replace(/\s+/g,'');
        let lower = clean.toLowerCase();

        let assignMatch = clean.match(/^([a-zA-Z_][a-zA-Z0-9_]*)=(.+)$/);
        if (assignMatch && !/^[xy]$/i.test(assignMatch[1])) {
            let varName = assignMatch[1].toLowerCase();
            let rhs = prepareExpression(assignMatch[2]);
            let rhsIds = findIdentifiers(rhs);
            if (!rhsIds.includes('x') && !rhsIds.includes('y') && !rhsIds.includes('t')) {
                return {
                    type: 'assignment', raw: raw, varName: varName, ids: rhsIds,
                    fn: new Function('vars', `${buildDestructure(rhsIds)}return ${rhs};`)
                };
            }
        }

        if(/x\s*=/.test(lower) && /y\s*=/.test(lower)){
            let parts = clean.split(',');
            let xPart = parts.find(p=>/x\s*=/.test(p.toLowerCase()));
            let yPart = parts.find(p=>/y\s*=/.test(p.toLowerCase()));
            let xExpr = prepareExpression(xPart.split('=')[1]);
            let yExpr = prepareExpression(yPart.split('=')[1]);
            let ids = findIdentifiers(xExpr + yExpr);
            return {
                type:'parametric', raw:raw, ids:ids,
                fn:new Function('t','vars', `${buildDestructure(ids)}return {x:(${xExpr}), y:(${yExpr})};`)
            };
        }

        let yMatch = clean.match(/^y=(.+)$/i);
        if (yMatch) {
            let rhs = prepareExpression(yMatch[1]);
            let ids = findIdentifiers(rhs);
            if (!ids.includes('y')) {
                return {
                    type: 'explicit-y', raw: raw, ids: ids,
                    fn: new Function('x', 'vars', `${buildDestructure(ids)}return ${rhs};`)
                };
            }
        }

        let xMatch = clean.match(/^x=(.+)$/i);
        if (xMatch) {
            let rhs = prepareExpression(xMatch[1]);
            let ids = findIdentifiers(rhs);
            if (!ids.includes('x')) {
                return {
                    type: 'explicit-x', raw: raw, ids: ids,
                    fn: new Function('y', 'vars', `${buildDestructure(ids)}return ${rhs};`)
                };
            }
        }

        let parts = clean.split('=');
        let lhs = parts.length > 1 ? prepareExpression(parts[0]) : 'y';
        let rhs = parts.length > 1 ? prepareExpression(parts.slice(1).join('=')) : prepareExpression(clean);
        let expr = `(${lhs}) - (${rhs})`;
        let ids = findIdentifiers(expr);
        return {
            type:'implicit', raw:raw, ids:ids,
            fn:new Function('x','y','vars', `${buildDestructure(ids)}return ${expr};`)
        };
    }catch(e){ return null; }
}

function getResult(text, currentVars) {
    if (!text || !text.trim()) return null;
    let clean = text.replace(/\s+/g,'').toLowerCase();
    let parts = clean.split('=');
    let exprToEval = clean;
    if (parts.length === 2) {
        let lhs = parts[0];
        if (!/^[a-z_][a-z0-9_]*$/.test(lhs)) return null;
        exprToEval = parts[1];
    } else if (parts.length > 2) {
        return null;
    }

    let ids = findIdentifiers(exprToEval);
    if (ids.includes('x') || ids.includes('y') || ids.includes('t')) return null;

    try {
        let prepared = prepareExpression(exprToEval);
        let fn = new Function('vars', `${buildDestructure(ids)}return ${prepared};`);
        let val = fn(currentVars);
        if (typeof val === 'number' && !isNaN(val) && isFinite(val)) return val;
    } catch(e) {}
    return null;
}

function refreshVars() {
    expressions.forEach((expr) => {
        if(expr.meta && expr.meta.type === 'assignment') {
            try {
                let val = expr.meta.fn(vars);
                if(typeof val === 'number' && !isNaN(val) && isFinite(val)) {
                    vars[expr.meta.varName] = val;
                }
            } catch(e) {}
        }
    });
}

function updateResults() {
    expressions.forEach((expr, i) => {
        let container = listEl.children[i];
        if (!container) return;
        let resEl = container.querySelector('.expr-result');
        if (!resEl) return;
        
        let val = getResult(expr.text, vars);
        if (val !== null) {
            resEl.innerText = '= ' + (Number.isInteger(val) ? val : parseFloat(val.toFixed(4)));
            resEl.style.display = 'block';
        } else {
            resEl.style.display = 'none';
        }
    });
}

function updateState() {
    expressions.forEach(e => e.meta = parseMath(e.text));
    
    explicitAssignments = {};
    assignmentSources = {};
    let collected = new Set();

    expressions.forEach((expr, i) => {
        if(expr.meta && expr.meta.type === 'assignment') {
            try {
                let evalContext = {...vars, ...explicitAssignments};
                let val = expr.meta.fn(evalContext);
                if(typeof val === 'number' && !isNaN(val)) {
                    explicitAssignments[expr.meta.varName] = val;
                    assignmentSources[expr.meta.varName] = i;
                    collected.add(expr.meta.varName);
                }
            } catch(e) {}
        }
    });

    pendingPrompts = {};
    expressions.forEach((expr, i) => {
        if (!expr.meta || expr.meta.type === 'assignment') return;
        let ids = (expr.meta.ids || []).map(id => id.toLowerCase()).filter(id => id !== 'y');
        ids.forEach(id => collected.add(id));
        
        let freeVars = ids.filter(id => !['x','t'].includes(id) && explicitAssignments[id] === undefined && !explicitParams.has(id));
        
        if (ids.includes('x') || ids.includes('t')) {
            if (freeVars.length > 0) pendingPrompts[i] = freeVars;
        } else if (freeVars.length > 1) {
            pendingPrompts[i] = freeVars;
        }
    });

    for (let p of explicitParams) {
        if (!collected.has(p)) explicitParams.delete(p);
    }

    let newVars = {};
    collected.forEach(id => {
        if (explicitAssignments[id] !== undefined) {
            newVars[id] = explicitAssignments[id];
        } else {
            newVars[id] = (vars[id] !== undefined) ? vars[id] : 1;
        }
    });
    
    vars = newVars;
}

function draw(){
    ctx.fillStyle="#121212";
    ctx.fillRect(0,0,width,height);
    drawGrid();

    expressions.forEach(eq=>{
        if(!eq.meta || !eq.meta.fn || eq.meta.type === 'assignment') return;
        ctx.strokeStyle=eq.color;
        ctx.fillStyle=eq.color;
        ctx.lineWidth = 2;

        if(eq.meta.type==='explicit-y'){
            ctx.beginPath();
            let first = true;
            for(let px = 0; px <= width; px += 2){
                let mx = (px - width/2 - view.x)/view.scale;
                try {
                    let my = eq.meta.fn(mx, vars);
                    if (typeof my !== 'number' || isNaN(my)) { first = true; continue; }
                    let py = height/2 + view.y - my * view.scale;
                    if (py < -5000 || py > height + 5000) { first = true; continue; }
                    if(first){ ctx.moveTo(px,py); first = false; } else { ctx.lineTo(px,py); }
                } catch(e) { first = true; }
            }
            ctx.stroke();
            return;
        }

        if(eq.meta.type==='explicit-x'){
            ctx.beginPath();
            let first = true;
            for(let py = 0; py <= height; py += 2){
                let my = -((py - height/2 - view.y)/view.scale);
                try {
                    let mx = eq.meta.fn(my, vars);
                    if (typeof mx !== 'number' || isNaN(mx)) { first = true; continue; }
                    let px = mx * view.scale + width/2 + view.x;
                    if (px < -5000 || px > width + 5000) { first = true; continue; }
                    if(first){ ctx.moveTo(px,py); first = false; } else { ctx.lineTo(px,py); }
                } catch(e) { first = true; }
            }
            ctx.stroke();
            return;
        }

        if(eq.meta.type==='parametric'){
            ctx.beginPath();
            let first=true;
            for(let t=-10; t<=10; t+=0.02){
                try{
                    let p = eq.meta.fn(t,vars);
                    let px = p.x*view.scale + width/2 + view.x;
                    let py = height/2 + view.y - p.y*view.scale;
                    if(first){ ctx.moveTo(px,py); first=false; } else { ctx.lineTo(px,py); }
                }catch(e){}
            }
            ctx.stroke();
            return;
        }

        const RESOLUTION = Math.max(3, Math.floor(6/(view.scale/40)));
        const ids = (eq.meta.ids || []).map(id => id.toLowerCase());
        const primaryVar = ids.find(id => id !== 'y' && !explicitParams.has(id) && explicitAssignments[id] === undefined && id !== 't') || 'x';

        ctx.lineWidth = 1.2;
        for(let screenX=0; screenX<width; screenX+=RESOLUTION){
            let mx = (screenX - width/2 - view.x)/view.scale;
            for(let screenY=0; screenY<height; screenY+=RESOLUTION){
                let my = -((screenY - height/2 - view.y)/view.scale);
                let localVars = {...vars};
                localVars[primaryVar] = mx;

                try{
                    let val = eq.meta.fn(mx,my,localVars);
                    let localVarsR = {...localVars};
                    localVarsR[primaryVar] = mx + RESOLUTION/view.scale;
                    let valR = eq.meta.fn(mx + RESOLUTION/view.scale, my, localVarsR);
                    let valD = eq.meta.fn(mx, my - RESOLUTION/view.scale, localVars);
                    
                    if(Math.sign(val)!==Math.sign(valR)){
                        ctx.fillRect(screenX + (val/(val-valR))*RESOLUTION, screenY, 1.5, 1.5);
                    }
                    if(Math.sign(val)!==Math.sign(valD)){
                        ctx.fillRect(screenX, screenY + (val/(val-valD))*RESOLUTION, 1.5, 1.5);
                    }
                }catch(e){}
            }
        }
    });

    if (mousePos.x !== null) drawTooltip();
}

function resolveTooltipValue(eq, lx, ly, localVars) {
    if (eq.meta.type === 'explicit-y') return ly - eq.meta.fn(lx, localVars);
    if (eq.meta.type === 'explicit-x') return lx - eq.meta.fn(ly, localVars);
    return eq.meta.fn(lx, ly, localVars);
}

function drawTooltip() {
    if (drag.active) return;
    const radius = 16;
    let pointSets = [];
    
    expressions.forEach(eq => {
        if(!eq.meta || !eq.meta.fn || eq.meta.type==='parametric' || eq.meta.type === 'assignment') return;
        let pts = [];
        const ids = (eq.meta.ids || []).map(id => id.toLowerCase());
        const primaryVar = ids.find(id => id !== 'y' && !explicitParams.has(id) && explicitAssignments[id] === undefined && id !== 't') || 'x';
        
        let localVars = {...vars};
        let step = 2/view.scale;
        try {
            for(let sx = mousePos.x - radius; sx <= mousePos.x + radius; sx += 2) {
                let lx = (sx - width/2 - view.x)/view.scale;
                localVars[primaryVar] = lx;
                for(let sy = mousePos.y - radius; sy <= mousePos.y + radius; sy += 2) {
                    let ly = -((sy - height/2 - view.y)/view.scale);
                    
                    let val = resolveTooltipValue(eq, lx, ly, localVars);
                    let valR = resolveTooltipValue(eq, lx + step, ly, localVars);
                    let valD = resolveTooltipValue(eq, lx, ly - step, localVars);
                    
                    if(Math.sign(val) !== Math.sign(valR) || Math.sign(val) !== Math.sign(valD)){
                        pts.push({x: sx, y: sy, mx: lx, my: ly});
                    }
                }
            }
        } catch(e) {}
        if(pts.length > 0) pointSets.push(pts);
    });

    let xPts = [], yPts = [];
    for(let sx = mousePos.x - radius; sx <= mousePos.x + radius; sx += 2) {
        let lx = (sx - width/2 - view.x)/view.scale;
        for(let sy = mousePos.y - radius; sy <= mousePos.y + radius; sy += 2) {
            let ly = -((sy - height/2 - view.y)/view.scale);
            if(Math.abs(ly) <= 2/view.scale) xPts.push({x:sx, y:sy, mx:lx, my:0});
            if(Math.abs(lx) <= 2/view.scale) yPts.push({x:sx, y:sy, mx:0, my:ly});
        }
    }
    if(xPts.length > 0) pointSets.push(xPts);
    if(yPts.length > 0) pointSets.push(yPts);

    let bestDist = Infinity;
    let target = null;

    for(let i=0; i<pointSets.length; i++){
        for(let j=i+1; j<pointSets.length; j++){
            for(let p1 of pointSets[i]){
                for(let p2 of pointSets[j]){
                    let d = Math.hypot(p1.x - p2.x, p1.y - p2.y);
                    if(d < 6 && d < bestDist){
                        bestDist = d;
                        target = { x: (p1.x+p2.x)/2, y: (p1.y+p2.y)/2, mx: (p1.mx+p2.mx)/2, my: (p1.my+p2.my)/2 };
                    }
                }
            }
        }
    }

    if (target) {
        if (Math.abs(target.mx) < 0.05) target.mx = 0;
        if (Math.abs(target.my) < 0.05) target.my = 0;
        ctx.beginPath(); ctx.arc(target.x, target.y, 5, 0, Math.PI*2);
        ctx.fillStyle = '#1e1e1e'; ctx.fill();
        ctx.lineWidth = 2; ctx.strokeStyle = '#fff'; ctx.stroke();
        let txt = `(${Math.round(target.mx*100)/100}, ${Math.round(target.my*100)/100})`;
        ctx.font = '12px "Segoe UI", monospace';
        let tw = ctx.measureText(txt).width;
        ctx.fillStyle = 'rgba(0,0,0,0.8)';
        ctx.fillRect(target.x + 10, target.y - 12, tw + 16, 24);
        ctx.fillStyle = '#fff';
        ctx.fillText(txt, target.x + 18, target.y + 4);
        canvas.style.cursor = 'pointer';
    } else {
        canvas.style.cursor = 'crosshair';
    }
}

function drawGrid(){
    const targetSpacing = 80;
    const targetUnits = targetSpacing / view.scale;
    const mag = Math.pow(10, Math.floor(Math.log10(targetUnits)));
    const norm = targetUnits / mag;
    
    let step = mag;
    if (norm > 7.5) step = 10 * mag;
    else if (norm > 3.5) step = 5 * mag;
    else if (norm > 1.5) step = 2 * mag;

    const minorStep = step / 5;
    
    ctx.strokeStyle = "#1a1a1a";
    ctx.lineWidth = 1;
    ctx.beginPath();
    let startX = Math.floor((-width/2 - view.x)/view.scale / minorStep) * minorStep;
    let endX = Math.ceil((width/2 - view.x)/view.scale / minorStep) * minorStep;
    for(let i=startX; i<=endX; i+=minorStep){
        let px = i * view.scale + width/2 + view.x;
        ctx.moveTo(px, 0); ctx.lineTo(px, height);
    }
    let startY = Math.floor((-height/2 + view.y)/view.scale / minorStep) * minorStep;
    let endY = Math.ceil((height/2 + view.y)/view.scale / minorStep) * minorStep;
    for(let i=startY; i<=endY; i+=minorStep){
        let py = height/2 + view.y - i * view.scale;
        ctx.moveTo(0, py); ctx.lineTo(width, py);
    }
    ctx.stroke();

    ctx.strokeStyle = "#333";
    ctx.lineWidth = 1;
    ctx.beginPath();
    startX = Math.floor((-width/2 - view.x)/view.scale / step) * step;
    endX = Math.ceil((width/2 - view.x)/view.scale / step) * step;
    for(let i=startX; i<=endX; i+=step){
        let px = i * view.scale + width/2 + view.x;
        ctx.moveTo(px, 0); ctx.lineTo(px, height);
    }
    startY = Math.floor((-height/2 + view.y)/view.scale / step) * step;
    endY = Math.ceil((height/2 + view.y)/view.scale / step) * step;
    for(let i=startY; i<=endY; i+=step){
        let py = height/2 + view.y - i * view.scale;
        ctx.moveTo(0, py); ctx.lineTo(width, py);
    }
    ctx.stroke();

    let originX = width/2 + view.x;
    let originY = height/2 + view.y;
    
    ctx.strokeStyle = "#888";
    ctx.lineWidth = 2;
    ctx.beginPath();
    if (originX >= 0 && originX <= width) {
        ctx.moveTo(originX, 0); ctx.lineTo(originX, height);
    }
    if (originY >= 0 && originY <= height) {
        ctx.moveTo(0, originY); ctx.lineTo(width, originY);
    }
    ctx.stroke();

    ctx.fillStyle = "#aaa";
    ctx.font = "12px 'Segoe UI', monospace";
    
    const formatLabel = (val) => {
        let res = parseFloat(val.toPrecision(12));
        return res === 0 ? "" : res.toString();
    };

    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    let labelY = Math.max(15, Math.min(height - 20, originY + 5));
    for(let i=startX; i<=endX; i+=step){
        if (Math.abs(i) < step*0.01) continue;
        let px = i * view.scale + width/2 + view.x;
        ctx.fillText(formatLabel(i), px, labelY);
    }

    ctx.textAlign = "right";
    ctx.textBaseline = "middle";
    let labelX = Math.max(25, Math.min(width - 10, originX - 5));
    for(let i=startY; i<=endY; i+=step){
        if (Math.abs(i) < step*0.01) continue;
        let py = height/2 + view.y - i * view.scale;
        ctx.fillText(formatLabel(i), labelX, py);
    }
    
    ctx.textAlign = "right";
    ctx.textBaseline = "top";
    ctx.fillText("0", labelX, labelY);
}

function syncAssignment(v, newVal) {
    if (assignmentSources[v] !== undefined) {
        let idx = assignmentSources[v];
        let valStr = Number.isInteger(newVal) ? newVal.toString() : newVal.toFixed(2);
        expressions[idx].text = `${v}=${valStr}`;
        expressions[idx].meta = parseMath(expressions[idx].text);
        let container = listEl.children[idx];
        if (container) {
            let inputField = container.querySelector('.expr-input');
            if (inputField) inputField.value = expressions[idx].text;
        }
    }
}

function renderList() {
    while(listEl.children.length > expressions.length) listEl.lastChild.remove();
    while(listEl.children.length < expressions.length) {
        let row = document.createElement('div');
        row.className = 'expr-row-container';
        row.innerHTML = `
            <div class="expr-row">
                <div class="expr-color"></div>
                <input class="expr-input" placeholder="Enter equation...">
                <span class="expr-delete">×</span>
            </div>
            <div class="expr-result" style="display:none;"></div>
            <div class="slider-prompt" style="display:none;"></div>
        `;
        listEl.appendChild(row);
    }

    expressions.forEach((expr, i) => {
        let container = listEl.children[i];
        let row = container.querySelector('.expr-row');
        let colorIndicator = container.querySelector('.expr-color');
        let input = container.querySelector('.expr-input');
        let del = container.querySelector('.expr-delete');
        let prompt = container.querySelector('.slider-prompt');

        row.style.borderLeftColor = expr.color;
        colorIndicator.style.background = expr.color;
        
        if (input.value !== expr.text) input.value = expr.text;
        input.oninput = (e) => window.updateExpr(i, e.target.value);
        del.onclick = () => window.removeExpr(i);

        if (pendingPrompts[i]) {
            prompt.style.display = 'flex';
            prompt.innerHTML = `<span style="color:#888;font-size:12px;margin-right:8px;">add slider:</span>`;
            pendingPrompts[i].forEach(v => {
                let btn = document.createElement('button');
                btn.className = 'prompt-btn'; btn.innerText = v;
                btn.onclick = () => { explicitParams.add(v); fullUpdate(); };
                prompt.appendChild(btn);
            });
            if (pendingPrompts[i].length > 1) {
                let btn = document.createElement('button');
                btn.className = 'prompt-btn'; btn.innerText = 'all';
                btn.onclick = () => {
                    pendingPrompts[i].forEach(v => explicitParams.add(v));
                    fullUpdate();
                };
                prompt.appendChild(btn);
            }
        } else {
            prompt.style.display = 'none';
            prompt.innerHTML = '';
        }
    });
    renderSliders();
    updateResults();
}

function renderSliders(){
    let existing=document.getElementById('sliders');
    if(existing) existing.remove();
    
    let sliderVars = Array.from(explicitParams).concat(Object.keys(assignmentSources));
    sliderVars = [...new Set(sliderVars)];
    
    if(sliderVars.length === 0) return;

    sliderVars.forEach(v => {
        if (!animState[v]) animState[v] = { playing: false, dir: 1, min: -10, max: 10, speed: 0.5 };
    });
    
    let box=document.createElement('div');
    box.id='sliders';
    box.innerHTML = '<div class="note">Variables defined as parameters appear as sliders.</div>';
    
    sliderVars.forEach(v=>{
        let container = document.createElement('div');
        
        let header = document.createElement('div');
        header.className = 'slider-header';

        let label = document.createElement('label');
        label.id = 'label-' + v;
        label.innerText = `${v}: ${typeof vars[v] === 'number' ? vars[v].toFixed(2) : vars[v]}`;
        label.style.margin = '0';

        let playBtn = document.createElement('button');
        playBtn.className = 'play-btn';
        playBtn.innerText = animState[v].playing ? 'Pause' : 'Play';
        playBtn.onclick = () => {
            animState[v].playing = !animState[v].playing;
            playBtn.innerText = animState[v].playing ? 'Pause' : 'Play';
        };

        header.appendChild(label);
        header.appendChild(playBtn);
        
        let input=document.createElement('input');
        input.id = 'slider-' + v;
        input.type='range'; 
        input.min = animState[v].min;
        input.max = animState[v].max;
        input.step=0.01; 
        input.value=vars[v];
        
        input.oninput=()=>{
            let newVal = parseFloat(input.value);
            vars[v] = newVal;
            label.innerText = `${v}: ${newVal.toFixed(2)}`;
            syncAssignment(v, newVal);
            refreshVars();
            updateResults();
            requestDraw();
        };

        container.appendChild(header);
        container.appendChild(input);
        box.appendChild(container);
    });
    document.getElementById('sidebar').appendChild(box);
}

function fullUpdate() {
    updateState();
    renderList();
    requestDraw();
}

window.updateExpr=(i,text)=>{
    expressions[i].text=text;
    fullUpdate();
};

window.addExpression=()=>{
    expressions.push({text:"",color:COLORS[expressions.length%COLORS.length],meta:null});
    fullUpdate();
};

window.removeExpr=i=>{
    expressions.splice(i,1);
    if(expressions.length === 0) expressions.push({text:"",color:COLORS[0],meta:null});
    fullUpdate();
};

function requestDraw(){
    if(renderId) cancelAnimationFrame(renderId);
    renderId=requestAnimationFrame(draw);
}

function resize(){
    width=canvas.parentElement.clientWidth;
    height=canvas.parentElement.clientHeight;
    canvas.width=width; canvas.height=height;
    requestDraw();
}

new ResizeObserver(resize).observe(document.getElementById('canvas-wrapper'));

canvas.addEventListener('mousedown',e=>{ drag.active=true; drag.lastX=e.clientX; drag.lastY=e.clientY; });
canvas.addEventListener('mouseup',()=>drag.active=false);
canvas.addEventListener('mousemove',e=>{
    if(drag.active){
        view.x+=e.clientX-drag.lastX; view.y+=e.clientY-drag.lastY;
        drag.lastX=e.clientX; drag.lastY=e.clientY;
        mousePos.x = null;
    } else {
        const rect = canvas.getBoundingClientRect();
        mousePos.x = e.clientX - rect.left; mousePos.y = e.clientY - rect.top;
    }
    requestDraw();
});
canvas.addEventListener('mouseleave', () => { mousePos.x = null; mousePos.y = null; drag.active = false; requestDraw(); });
canvas.addEventListener('wheel',e=>{
    e.preventDefault();
    const oldScale = view.scale;
    view.scale *= e.deltaY>0?0.9:1.1;
    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left - width/2 - view.x)/oldScale;
    const my = -((e.clientY - rect.top - height/2 - view.y)/oldScale);
    view.x = view.x - (view.scale - oldScale)*mx;
    view.y = view.y + (view.scale - oldScale)*my;
    requestDraw();
});

let lastTime = performance.now();
function animLoop(time) {
    let dt = (time - lastTime) / 1000;
    lastTime = time;
    if (dt > 0.1) dt = 0.1;

    let needsDraw = false;
    for (let v in animState) {
        let st = animState[v];
        if (st.playing) {
            let range = st.max - st.min;
            vars[v] += (range * st.speed * dt) * st.dir;
            
            if (vars[v] >= st.max) { vars[v] = st.max; st.dir = -1; }
            if (vars[v] <= st.min) { vars[v] = st.min; st.dir = 1; }

            let slider = document.getElementById('slider-' + v);
            if (slider) slider.value = vars[v];
            let label = document.getElementById('label-' + v);
            if (label) label.innerText = `${v}: ${vars[v].toFixed(2)}`;

            syncAssignment(v, vars[v]);
            needsDraw = true;
        }
    }
    if (needsDraw) {
        refreshVars();
        updateResults();
        draw();
    }
    requestAnimationFrame(animLoop);
}

requestAnimationFrame(animLoop);
fullUpdate();
</script>
</body>
</html>